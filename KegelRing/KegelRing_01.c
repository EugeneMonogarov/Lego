#pragma config(Sensor, S1,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S3,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S4,     sLight,         sensorLightActive)
#pragma config(Motor,  motorA,          mLeft,         tmotorEV3_Large, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          mRight,        tmotorEV3_Large, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{

	SensorValue(sLight) = 0;
	SensorValue(sSonarLeft) = 0;
	SensorValue(sSonarRight) = 0;

	const int black    = 20;
	const int maxSpeed = 100;
	int v = maxSpeed; 							// current speed
	const int distance = 70;

	int lastAction=0; // 0 - start, 1 - back; 2 - forward; 3 - turn left; 4 - turn right

	while(true)
	{
		sleep(1);

		int light = SensorValue(sLight);

		if (light < black) // back
		{
			for ( int i = -60; i<=maxSpeed; i = i + 20) // slow back
			{
				/*
				if (lastAction == 3 ) //turn left
				{
				motor[mLeft] = -i * 0.5;
				motor[mRight] = -i  ;
				}
				else
				{
				motor[mLeft] = -i ;
				motor[mRight] = -i *0.5;
				}
				*/
				motor[mLeft] = -i * 0.4;
				motor[mRight] = -i  ;
				sleep(75);
			}
			for ( int i = maxSpeed; i>0; i = i - 10) // slow stop
			{
				/*
				if (lastAction ==3 ) //turn left
				{
				motor[mLeft] = -i * 0.5;
				motor[mRight] = -i   ;
				}
				else
				{
				motor[mLeft] = -i ;
				motor[mRight] = -i *0.5;
				}
				*/
				motor[mLeft] = -i ;
				motor[mRight] = -i *0.4;
				sleep(75);

			}


			lastAction = 1; // back
		}
		else
		{
			int sonarLeft = SensorValue(sSonarLeft);
			int sonarRight = SensorValue(sSonarRight);
			/*
			if (lastAction == 1)
			v = 0;
			else
			{
			if (v < maxSpeed)
			v = v + 4;
			else
			v = maxSpeed;
			}
			*/
			if ((sonarLeft < distance) && (sonarRight < distance)) // forward
			{
				motor[mLeft]  = v ;
				motor[mRight] = v ;
				lastAction = 2; // forward
				continue;
			}
			if (sonarLeft < distance) // turn left
			{
				motor[mLeft] = v / 2;
				motor[mRight] = v ;
				lastAction = 3; // turn left
				continue;
			}
			if (sonarRight < distance) // turn right
			{
				motor[mLeft] = v ;
				motor[mRight] = v / 2 ;
				lastAction = 4; // turn right
				continue;
			}
		}
	}
}
