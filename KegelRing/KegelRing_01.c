#pragma config(Sensor, S1,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S3,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S4,     sLight,         sensorLightActive)
#pragma config(Motor,  motorA,          mLeft,         tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorD,          mRight,        tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{

	SensorValue(sLight) = 0;
	SensorValue(sSonarLeft) = 0;
	SensorValue(sSonarRight) = 0;

	const int black    = 20;
	const int maxSpeed = 100;
	int v = maxSpeed; 							// current speed
	const int distance = 70;

	int lastAction=0; // 0 - start, 1 - back; 2 - forward; 3 - turn left; 4 - turn right

	while(true)
	{
		sleep(1);

		int light = SensorValue(sLight);

		if (light < black) // back
		{
			for ( int i = -60; i<=maxSpeed; i = i + 20) // slow back
			{
				motor[mLeft] = -i * 0.4;
				motor[mRight] = -i  ;
				sleep(50);
			}
			for ( int i = maxSpeed; i>0; i = i - 10) // slow stop
			{
				motor[mLeft] = -i ;
				motor[mRight] = -i *0.4;
				sleep(100);

			}
			lastAction = 1; // back
		}
		else
		{
			int sonarLeft = SensorValue(sSonarLeft);
			int sonarRight = SensorValue(sSonarRight);

			if ((sonarLeft < distance) && (sonarRight < distance)) // forward
			{
				motor[mLeft]  = v ;
				motor[mRight] = v ;
				lastAction = 2; // forward
			}
			else
			{
				if (sonarLeft < distance) // turn left
				{
					motor[mLeft] = v / 2;
					motor[mRight] = v ;
					lastAction = 3; // turn left
				}
				else // turn right
				{
					motor[mLeft] = v ;
					motor[mRight] = v / 2 ;
					lastAction = 4; // turn right
				}
			}
		}
	}
}
