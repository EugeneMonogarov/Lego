#pragma config(Sensor, S1,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S2,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S3,     sTouch,         sensorTouch)
#pragma config(Sensor, S4,     sLight,         sensorI2CCustom9V)
#pragma config(Motor,  motorA,          mShLeft,       tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

bool IsHereWhite();

task main()
{
	//-----------------------------------------------------
	while (SensorValue(sTouch)== 0)
	{
		sleep (10);
	}
	while (SensorValue(sTouch)== 1)
	{
		sleep (10);
	}

	//-----------------------------------------------------
	sleep (5000);
	//-----------------------------------------------------

	//-----------------------------------------------------
	motor[mShLeft]=100; 				// shovel down
	for (int i = 10; i <= 130; i = i + 10)
	{
		motor[mLeft]  = i;					// go ahead smoothly
		motor[mRight] = i;					// go ahead smoothly
		sleep(10);
	}
	motor[mShLeft]=10; 		// shovel light pressure
	//-----------------------------------------------------

	//-----------------------------------------------------
	const int sonarDistance  = 55;
	int sonarLeft 					 = 0;				// current left sonar sensor
	int sonarRight 					 = 0;				// current left sonar sensor
	SensorValue(sSonarLeft)	 = 0;				// init left sonar sensor
	SensorValue(sSonarRight) = 0;				// init right sonar sensor
	//-----------------------------------------------------

	int sensor = LLreadResult(sLight);

	// Initit motors
	//-----------------------------------------------------
	int vLeft 	= 100;					// left motor power
	int vRight 	= 100;					// right motor power

	motor[mLeft]  = vLeft;					// go ahead
	motor[mRight] = vRight;					// go ahead
	//-----------------------------------------------------

	while (true)
	{
		// Get light sensor value and turn when current value less or more than start value
		//-----------------------------------------------------
		if ( IsHereWhite() ) // U turn
		{
			motor[mLeft]  = -100; 		// move back
			motor[mRight] = -100;		  // move back
			sleep(350);
			motor[mLeft]  =  50;		  // turn
			motor[mRight] = -50;		  // turn
			sleep(350);
		}
		//-----------------------------------------------------

		// use sonar sensor here
		//-----------------------------------------------------
		sonarLeft  = SensorValue(sSonarLeft);
		sonarRight = SensorValue(sSonarRight);

		if ( sonarLeft  < 5 ) sonarLeft  = 255; // protects from stupid sonar issue when value is 0
			if ( sonarRight < 5 ) sonarRight = 255; // protects from stupid sonar issue when value is 0

		if ( sonarLeft < sonarDistance ) // see on the left
		{
			if ( sonarRight < sonarDistance ) // see on the right too. Go ahead
			{
				if (( sonarLeft < 15 ) | ( sonarRight < 15 )) // max power go ahead. Kill it
				{
					vLeft  = 100 ;
					vRight = 100 ;
				}
				else  // smart go ahead
				{
					vLeft  = 100 * sonarLeft / sonarRight ;
					vRight = 100 * sonarRight / sonarLeft ;
				}
			}
			else // see only left only. Turn left
			{
				vLeft  =  15;
				vRight = -15;
			}
		}
		else
		{
			if ( sonarRight < sonarDistance ) // see on the right only. Turn right
			{
				vLeft  = -15;
				vRight =  15;
			}
		}

		// sets motors power value
		motor[mLeft]  = vLeft;
		motor[mRight] = vRight;
		sleep(1);
	}
}

// returns true when value of anysensor more than 45
bool IsHereWhite()
{
	tByteArray signalstr;
	LLreadSensorRaw(sLight, signalstr); // read the raw sensor data (8 bit data)

	for (int i = 0 ; i < 8; i++)
	{
		if ( signalstr[i] > 50 ) return true;
	}
	return false;
}
