#pragma config(Sensor, S1,     sSonarLeft,     sensorSONAR)
#pragma config(Sensor, S2,     sSonarRight,    sensorSONAR)
#pragma config(Sensor, S4,     sLight,         sensorI2CCustom9V)
#pragma config(Motor,  motorA,          mShLeft,       tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-lineleader.h"

int GetLightAverage();
bool IsHereWhite();

task main()
{
	//-----------------------------------------------------
	sleep (3000);
	motor[mShLeft]=100;					// shovel down
	sleep(200);
	motor[mShLeft]=5;					// shovel light pressure
	//-----------------------------------------------------

	//-----------------------------------------------------
	const int sonarDistance  = 50;
	int sonarLeft 					 = 0;	// current left sonar sensor
	int sonarRight 					 = 0;	// current left sonar sensor
	SensorValue(sSonarLeft)	 = 0;				// init left sonar sensor
	SensorValue(sSonarRight) = 0;				// init right sonar sensor
	//-----------------------------------------------------

	//-----------------------------------------------------
	// int lightStart = GetLightAverage(); // remember initial light
	//-----------------------------------------------------

	// Initit motors
	//-----------------------------------------------------
	int vLeft 	= 100;					// left motor power
	int vRight 	= 100;					// right motor power

	motor[mLeft] = vLeft;					// go ahead
	motor[mRight] = vRight;					// go ahead
	//-----------------------------------------------------

	while (true)
	{
		// Get light sensor value and turn when current value less or more than start value
		//-----------------------------------------------------
		//if (abs(GetLightAverage() - lightStart) > 45) // U turn
		if ( IsHereWhite() ) // U turn
		{
			motor[mLeft]  = -100; 		// move back
			motor[mRight] = -100;		// move back
			sleep(300);
			motor[mLeft]  =  50;		// turn
			motor[mRight] = -50;		// turn
			sleep(250);
		}
		//-----------------------------------------------------


		// use sonar sensor here
		//-----------------------------------------------------
		sonarLeft  = SensorValue(sSonarLeft);
		sonarRight = SensorValue(sSonarRight);

		if ( sonarLeft < sonarDistance ) // see on the left
		{
			if ( sonarRight < sonarDistance ) // see on the right too. Go ahead
			{
				vLeft  = 100;
				vRight = 100;
			}
			else // see only left only. Turn left
			{
				vLeft  =  0;
				vRight = -20;
			}
		}
		else
		{
			if ( sonarRight < sonarDistance ) // see on the right only. Turn right
			{
				vLeft  = -20;
				vRight =  0;
			}
		}
	}
	// sets motors power value
	motor[mLeft]=vLeft;
	motor[mRight]=vRight;
}


// retruns light average from 0 - black to 100 - white
int GetLightAverage()
{
	int average = 0;
	int sensor = LLreadResult(sLight); // fetch the data from the sensor
	tByteArray signalstr;

	LLreadSensorRaw(sLight, signalstr); // read the raw sensor data (8 bit data)

	for (int i = 0 ; i<8; i++)
	{
		average += signalstr[i];
	}
	average /= 8;
	return average;
}

// returns true when value of anysensor more than 70
bool IsHereWhite()
{
	int sensor = LLreadResult(sLight); // fetch the data from the sensor
	tByteArray signalstr;

	LLreadSensorRaw(sLight, signalstr); // read the raw sensor data (8 bit data)

	for (int i = 0 ; i < 8; i++)
	{
		if ( signalstr[i] > 70) return true;
	}
	return false;
}
